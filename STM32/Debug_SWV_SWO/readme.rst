=================================================
**Профилировщик программ**
=================================================

**Содержание**: *Пример работы профилировщика на STM32 для использования в проектах на C++*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        example    | Исходный код проекта с примером  |
+-------------------+----------------------------------+
|  src              | Изображения                      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Теория`_
      #. `Настройка`_ 
      #. `Запуск и отладка`_  
      #. `Обзор возможностей`_  
      #. `Вывод`_  

**Теория**
--------------

Упрощает проверку кода на быстродействие. Выводит сколько мс было затрачено на выполнение того или иного кода. Без применения таймеров, не занимает их!!!!!!

**Настройка**
--------------

1) Добавляем файл ``profile.h`` в проект.

2) Подключаем файл в main.cpp, а именно пишем такую строку: ``#include "profile.h"``

3) После чего переходим в файл ``stm32f4xx_it.c`` (это файл с прерываниями)
      Здесь нам понадобиться объявить переменную: 
      
      .. code-block:: C
            
            extern uint64_t timer;
            
      После чего переходим в конец файла, а именно к функции ``SysTick_Handler`` это прерывание по системному таймеру. Тут мы итерируем каждую милисекунду ранее объявленный  таймер. Получиться такой код:  
      
      .. code-block:: C
      
            void SysTick_Handler(void)
            {
              /* USER CODE BEGIN SysTick_IRQn 0 */

              /* USER CODE END SysTick_IRQn 0 */
              HAL_IncTick();
              /* USER CODE BEGIN SysTick_IRQn 1 */
              ++timer;
              /* USER CODE END SysTick_IRQn 1 */
            }
            
4) Все. Настройка окончена. Переходим к использыванию.

**Запуск и отладка**
---------------------

Что бы запустить профайл надо применить один макрос и взять все это в скобки. Пример кода ниже.

.. code-block:: C

      {
		LOG_DURATION("test1");
		HAL_Delay(100);
	}

Обязательно использовать фигурные скобки!! Внутри них должен распологаться функционал скорость которого измеряем. Вместо текста "test1" может быть любое сообщение, которое в дальнейшем будет выведено в SWV порт.

**Обзор возможностей**
---------------------

Все вызовы ниже описаных окон осущиствляються через:

.. image:: src/pic4.png

**Консоль**
"""""""""""

Вызывается через окно ``SWV ITM Data Console`` имеет возможность выводить данные через printf как при отладке на ПК.


**График изменения переменной**
"""""""""""

Вызывается через окно ``WV Data Trace Timeline Graph`` удобно отслеживать накопления, отслеживает до 4 переменных, задаються переменные которые отслеживать через настройки в разделе ``Data Trace`` можно указывать область памяти или переменную, вроде работает только с глобальными. Рисунок настройки ниже (зеленая область).

.. image:: src/pic6.png

Пример реализации.

.. image:: src/pic6_1.png

**График прирываний**
"""""""""""

Вызывается через окно ``SWV Exception Timeline Graphic`` имеет возможность графически отслеживать прирывания в часовой области.

**Не большое отступление**
-------------------------

Так же есть возможность отслеживать изминение переменной. Работает только для глобальных переменных.

.. image:: src/pic8.png

**Вывод**
----------

Теперь можно сотворить такое:

.. image:: src/pic9.png
